# RSS Reader - 全文逐段翻译功能设计规范

> **版本**: v2.0
> **状态**: 设计稿
> **最后更新**: 2025-01

---

## 1. 功能概述

### 1.1 目标

为 RSS 文章阅读提供 **逐段沉浸式翻译** 体验：
- 翻译内容显示在原文段落下方
- 支持流式响应，翻译完成一段显示一段
- 基于内容哈希的智能缓存，避免重复翻译

### 1.2 设计原则

| 原则 | 说明 |
|------|------|
| **单一职责** | 前端负责分段和渲染，后端负责翻译和缓存 |
| **最小化请求** | 缓存优先，仅翻译未缓存段落 |
| **渐进增强** | 翻译失败不影响原文阅读 |
| **一致性** | 复用现有 `Translation` 模型和 AI 服务架构 |

---

## 2. 系统架构

### 2.1 数据流

```
┌─────────────────────────────────────────────────────────────────┐
│                        Frontend (Vue)                           │
├─────────────────────────────────────────────────────────────────┤
│  1. 用户点击 [翻译全文] 按钮                                      │
│  2. useArticleParser 解析 HTML → Block[]                        │
│  3. 过滤可翻译段落，生成 hash_id                                   │
│  4. 调用 POST /api/ai/translate-blocks                          │
│  5. 接收 SSE 流，逐段更新 UI                                      │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                        Backend (FastAPI)                        │
├─────────────────────────────────────────────────────────────────┤
│  1. 解析请求中的 blocks                                          │
│  2. 查询 Translation.paragraph_map 获取已缓存翻译                 │
│  3. 未命中的段落调用 LLM 批量翻译                                  │
│  4. SSE 流式返回翻译结果                                          │
│  5. 异步更新 paragraph_map 缓存                                   │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 组件关系

```
DetailsPanel.vue
├── DetailsActions.vue          # 操作按钮区（含翻译按钮）
├── ArticleContent.vue          # 文章内容渲染（新增组件）
│   └── TranslatableBlock.vue   # 可翻译段落组件（新增）
└── useArticleTranslation.ts    # 全文翻译 composable（新增）
    └── useArticleParser.ts     # HTML 解析 composable（已存在）
```

---

## 3. 前端设计

### 3.1 HTML 解析规则 (useArticleParser)

#### A. Block 类型定义

```typescript
interface ContentBlock {
  id: string           // 内容哈希 ID
  type: BlockType      // 块类型
  html: string         // 原始 HTML
  text: string         // 纯文本（用于翻译）
}

type BlockType =
  | 'text'             // 可翻译：p, li, h1-h6, blockquote
  | 'code'             // 不翻译：pre, code
  | 'media'            // 不翻译：img, video, iframe
  | 'skip'             // 跳过：空白、纯符号、导航噪音
```

#### B. 分段逻辑

```typescript
function parseArticleContent(html: string): ContentBlock[] {
  // 1. 创建 DOM 容器
  // 2. 遍历顶层元素，根据标签名分类
  // 3. 对 text 类型生成 hash_id
  // 4. 返回 Block 数组
}
```

#### C. 噪音过滤规则

将以下内容标记为 `skip` 类型：

| 规则 | 示例 |
|------|------|
| 空内容 | 仅空格或 `&nbsp;` |
| 纯符号 | `---`, `***`, `• • •` |
| 短文本无标点 | 少于 10 字符且无结束标点 |
| 日期/数字 | `2024-01-15`, `12345` |

#### D. Hash ID 生成

```typescript
function generateBlockId(text: string, sourceLang: string): string {
  // 1. 归一化文本
  const normalized = text
    .toLowerCase()
    .replace(/[^\p{L}\p{N}]/gu, '')  // 保留字母和数字

  // 2. 生成哈希（16位，降低碰撞概率）
  const hash = sha256(normalized + ':' + sourceLang)
  return hash.substring(0, 16)
}
```

> **注**: 使用 16 位十六进制（64 bits），生日悖论下约 50 亿条目才有 50% 碰撞概率。

### 3.2 翻译状态管理 (useArticleTranslation)

```typescript
interface ArticleTranslationState {
  // 状态
  isTranslating: boolean           // 是否正在翻译
  showTranslation: boolean         // 是否显示翻译
  translationProgress: number      // 进度 0-100

  // 缓存 Map<block_id, translated_text>
  translationMap: Map<string, string>

  // 错误
  failedBlocks: Set<string>        // 翻译失败的 block IDs
}
```

### 3.3 UI 渲染逻辑

#### A. 按钮状态机

```
┌─────────────┐    点击     ┌─────────────┐    完成     ┌─────────────┐
│   [翻译]    │ ─────────▶ │  [翻译中...]  │ ─────────▶ │  [隐藏翻译]  │
│  (idle)     │            │ (translating) │            │  (showing)   │
└─────────────┘            └─────────────┘            └─────────────┘
       ▲                                                      │
       └──────────────────── 点击 ◀───────────────────────────┘
```

#### B. 按钮文案映射

| 状态 | 文案 | disabled | 样式 |
|------|------|----------|------|
| `idle` | `翻译全文` | false | 默认 |
| `translating` | `翻译中 (45%)` | true | 加载动画 |
| `showing` | `隐藏翻译` | false | 高亮 |
| `error` | `重试翻译` | false | 错误色 |

#### C. 段落渲染结构

```vue
<template>
  <div v-for="block in blocks" :key="block.id" class="content-block">
    <!-- 原文 -->
    <div v-html="block.html" class="original" />

    <!-- 翻译（仅 text 类型且开启显示时渲染） -->
    <div
      v-if="block.type === 'text' && showTranslation"
      class="translation"
    >
      <!-- 骨架屏 -->
      <div v-if="isBlockLoading(block.id)" class="skeleton" />

      <!-- 翻译内容 -->
      <div v-else-if="getTranslation(block.id)" class="translated-text">
        {{ getTranslation(block.id) }}
      </div>

      <!-- 翻译失败 -->
      <div v-else-if="isBlockFailed(block.id)" class="error">
        翻译失败
      </div>
    </div>
  </div>
</template>
```

#### D. 样式规范

```css
.translation {
  margin-top: 8px;
  padding: 12px;
  background: var(--bg-elevated);
  border-left: 3px solid var(--accent-primary);
  border-radius: 4px;
  color: var(--text-secondary);
  font-size: 0.95em;
  line-height: 1.7;
}

.skeleton {
  height: 1.2em;
  background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
  background-size: 200% 100%;
  animation: shimmer 1.5s infinite;
  border-radius: 4px;
}

@keyframes shimmer {
  0% { background-position: 200% 0; }
  100% { background-position: -200% 0; }
}
```

---

## 4. 后端设计

### 4.1 API 接口

#### POST `/api/ai/translate-blocks`

**Request**:
```typescript
interface TranslateBlocksRequest {
  entry_id: string              // 文章 ID（用于缓存关联）
  source_lang: string           // 源语言 (如 "en")
  target_lang: string           // 目标语言 (如 "zh")
  blocks: Array<{
    id: string                  // block hash_id
    text: string                // 原文文本
  }>
}
```

**Response (SSE)**:
```
event: progress
data: {"total": 10, "completed": 0}

event: translation
data: {"id": "a1b2c3d4e5f67890", "text": "翻译后的内容..."}

event: translation
data: {"id": "b2c3d4e5f6789012", "text": "另一段翻译..."}

event: error
data: {"id": "c3d4e5f678901234", "error": "Rate limit exceeded"}

event: done
data: {"total": 10, "success": 9, "failed": 1, "cached": 5}
```

### 4.2 存储设计

复用现有 `Translation` 模型的 `paragraph_map` 字段：

```python
class Translation(SQLModel, table=True):
    # ... 现有字段 ...

    # paragraph_map 结构:
    # {
    #   "source_lang:target_lang": {
    #     "block_hash_id_1": "translated_text_1",
    #     "block_hash_id_2": "translated_text_2"
    #   }
    # }
    paragraph_map: Optional[dict] = Field(default=None, sa_column=Column(JSON))
```

**缓存键格式**: `{source_lang}:{target_lang}` → `{block_id}` → `translated_text`

### 4.3 翻译流程

```python
async def translate_blocks_stream(request: TranslateBlocksRequest):
    entry_id = request.entry_id
    cache_key = f"{request.source_lang}:{request.target_lang}"

    # 1. 加载现有缓存
    translation = await get_translation(entry_id, request.target_lang)
    cached_map = (translation.paragraph_map or {}).get(cache_key, {})

    # 2. 分离命中/未命中
    hits = []
    misses = []
    for block in request.blocks:
        if block.id in cached_map:
            hits.append((block.id, cached_map[block.id]))
        else:
            misses.append(block)

    # 3. 立即返回缓存命中
    for block_id, text in hits:
        yield sse_event("translation", {"id": block_id, "text": text})

    # 4. 批量翻译未命中段落
    # TODO: 未来可添加并发锁防止重复翻译（当前场景暂不需要）
    if misses:
        async for result in batch_translate(misses, request.target_lang):
            yield sse_event("translation", result)
            # 异步更新缓存
            await update_paragraph_cache(entry_id, cache_key, result)

    # 5. 发送完成事件
    yield sse_event("done", {
        "total": len(request.blocks),
        "success": len(hits) + success_count,
        "failed": fail_count,
        "cached": len(hits)
    })
```

### 4.4 LLM 调用策略

```python
async def batch_translate(blocks: list, target_lang: str):
    """分批调用 LLM 翻译"""
    BATCH_SIZE = 5  # 每批段落数

    for i in range(0, len(blocks), BATCH_SIZE):
        batch = blocks[i:i + BATCH_SIZE]

        prompt = build_translation_prompt(batch, target_lang)

        try:
            result = await ai_client.translate_batch(prompt)
            for block_id, text in parse_batch_result(result, batch):
                yield {"id": block_id, "text": text}
        except Exception as e:
            for block in batch:
                yield {"id": block.id, "error": str(e)}
```

**Prompt 模板**:
```
你是专业翻译。请将以下段落翻译成{target_lang}，保持原文格式和语气。

每段用 [ID:xxx] 标记，请保持对应关系。

[ID:a1b2c3d4]
The quick brown fox jumps over the lazy dog.

[ID:b2c3d4e5]
Hello, World!

请按以下格式输出：
[ID:a1b2c3d4]
敏捷的棕色狐狸跳过了懒狗。

[ID:b2c3d4e5]
你好，世界！
```

---

## 5. 文件清单

### 5.1 前端新增/修改

| 文件 | 操作 | 说明 |
|------|------|------|
| `src/composables/useArticleTranslation.ts` | **新增** | 全文翻译状态管理 |
| `src/components/details/ArticleContent.vue` | **新增** | 文章内容渲染组件 |
| `src/components/details/TranslatableBlock.vue` | **新增** | 可翻译段落组件 |
| `src/components/details/DetailsPanel.vue` | 修改 | 集成 ArticleContent |
| `src/components/details/DetailsActions.vue` | 修改 | 添加全文翻译按钮 |
| `src/api/client.ts` | 修改 | 添加 SSE 请求方法 |

### 5.2 后端新增/修改

| 文件 | 操作 | 说明 |
|------|------|------|
| `app/api/routes/ai.py` | 修改 | 添加 translate-blocks 端点 |
| `app/schemas/ai.py` | 修改 | 添加请求/响应模型 |
| `app/services/ai.py` | 修改 | 添加批量翻译方法 |

---

## 6. 开发计划

### Phase 1: 后端基础
- [ ] 实现 `POST /api/ai/translate-blocks` SSE 端点
- [ ] 实现 `paragraph_map` 缓存读写逻辑
- [ ] 实现批量翻译 Prompt 模板

### Phase 2: 前端核心
- [ ] 实现 `useArticleParser` HTML 解析
- [ ] 实现 `useArticleTranslation` 状态管理
- [ ] 实现 `ArticleContent` 组件

### Phase 3: 集成优化
- [ ] 集成到 DetailsPanel
- [ ] 添加骨架屏和错误处理
- [ ] 按钮状态联动
- [ ] 性能测试和调优

 
         
---

## 7. 注意事项

### 7.1 已知限制

1. **并发重复请求**: 当前设计不处理多个请求同时翻译相同段落的情况（暂不需要，因为同一文章不会并发请求）
   ```python
   # TODO: 如果未来需要跨文章缓存，可添加 Redis 锁
   # async with translation_lock(block_id):
   #     ...
   ```

2. **Hash 碰撞**: 使用 16 位哈希，理论上极低概率碰撞。如遇问题可扩展至 32 位。

### 7.2 兼容性

- 与现有 `Translation` 模型兼容，使用 `paragraph_map` 字段存储
- 不影响现有标题翻译功能 (`translate-title` 端点)
- 语言选择复用现有 `translationLanguage` 状态
